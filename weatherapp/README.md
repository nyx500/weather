# Final Project for CS50W: Weather App

## Distinctiveness

The aim of my project was to create a web application where the user is able to type in their location and then receive suggestions about what to wear and what to cook based on the weather in their chosen location. I have made my application responsive on smaller screens using a mixture of Bootstrap 4 and custom CSS including grid layouts, flexbox, and media queries. The app is also interactive and dynamic because of my use of JavaScript, API fetch requests, and the History API using pushState and replaceState.
This application is distinct from the other applications that I have created for this CS50 course as it is neither an e-commerce, a messaging, nor a social networking app. The function of this application is not to enable any buying and selling of goods or services between users, nor is it based on allowing messages and communication between people. There is a login option which enables the users to contribute to the database of recipes and food suggestions on the site but it is possible to use and enjoy the app without necessarily creating a user account. Anyone can type in the name of a city or town that they live in or want to visit and see the weather for either now, later in the day, or tomorrow, as well as lifestyle suggestions based on the returned and parsed data.

## Complexity

My project is significantly more complex in terms of both back-end and front end code than the other projects to date. Regarding the back-end, I have leveraged the power of models, model forms and JSONResponse as in the previous assignments. However, I have also created a list of complex functions in the functions.py document. These functions include the creation of a session to garner data from the Google search query for weather, to then parse the resulting HTML using Beautiful Soup, and creating an algorithm which takes the weather data, including variables such as wind and precipitation, to create a complex JSON object which returns the general weather assessment (or "feels-like" temperature) to the user, so that they can make a quick decision about what kind of produce to buy or what to wear. In terms of front-end, several sections of the app, especially the 'Recipes' section, work as a single-page app within the larger app. I have used JavaScript to enable to user to select several filters at once to narrow down their results. As mentioned above, I have also used more complex CSS which was necessary to make the grid layout of the recipes completely responsive.

## File Contents

### Python/Back-End Files

In my main views.py file, I have created standard index, login, register and logout routes as demonstrated in the previous projects. Apart from that, I have implemented an API route called get_data which responds to the user entering his or her location on the index page, which then sends a fetch request in the JavaScript file. This back-end function verifies if this location really exists, as well as changing the tense (present/future) returned in JSON based on whether the user clicked to see the weather report for now or later. This view uses the functions contained in functions.py toget the weather data from Google and to process the data to return a JSON object with the information about the weather and recipe suggestions to be sent back to the user. There is also a login-only submit route which validates the form data sent by the user on submitting the 'Submit Recipe' form, which checks if the image extensions on the recipe image URL work and whether the recipe URL is valid. If so, the form information is stored as a Recipe object. The get_city route was something I implemented in order to allow the user to refresh the loaded weather report page, so that the information about the weather conditions would be loaded from Google again on refresh instead of displaying old information. This was done by sending a variable to the Django template which is then read by the JS code and sends a fetch request to the get_data route again to keep the data relevant.
The models.py file includes three models: the default User model, a Weather model which I have filled in with possible Google weather types as an admin, and a Recipe model which links to the weather model using a ManyToManyRelationship. I have include a default __str__ and a serialize method in each model. I have used multiple choices to enable the user submitting a recipe to select from different kinds of cuisine, diet, weather, and the time of meal.
The forms.py file includes the Recipe form which serves as the template where a user can submit a new recipe when logged in. It also contains a stripped-down form called FilterForm with only the fields necessary for the user to filter down the recipes they want to see.
The functions.py defines two functions which validate the image URL that the user puts in while submitting the recipe, to make sure that the image's mimetype and format is in the above list of acceptable formats, as a security measure to make sure that the image that is linked is really an image file. The encode_weather_based_on_temp function rates the general weather condition based on the temperature and returns a general assessment of the temperature by adding more points the higher the temperature is. The change_feels_like_weather function changes the overall rating of the weather depending on the humidity and the wind speed. For exampele, if the weather is generally cold, then higher humidity makes it feel even colder, so the rating will be lower, whereas high humidity during warm weather will make it feel much warmer, so the rating is increased. get_html_content creates a fake user session to get Google weather data and returns it as a long chunk of HTML, which is then parsed in get_weather_data using Beautiful Soup 4 and passed into the functions mentioned above to calculate the general feels-like temperature. The find_recipes function is called within the get_weather_data function in order to get a list of recipes suitable for that particular weather type. The data is then encoded as a JSON object with sub-dictionaries for recipes and passed back to views.py

### Front-End/JavaScript Files

The script.js file includes several operations to be executed when the DOM content is loaded: it gets the user's location as a city if the user enables location services on their browser, it loads the weather data into the template when the weather form is submitted on the index page while hiding the form using the style.display 'none' property, it allows the user to pick different times and select either Celsius or Fahrenheit in the weather form, and it updates the state if the user navigates to the 'recipes' part of the app. The if_checked function returns the value of which checkbox has been selected for the time the user wants. The which_temperature function returns either Celsius or Fahrenheit as a string. The display_weather_information function creates and displays the HTML elements to show the user the weather information by using data from a fetch response, which is received in the get_data function when the user submits their location. The get_data function sends a request to the server to find the weather data for the user's entered city. It updates the state for each new city. The get_three and create_recipe_card functions are used in get_data to display the top three most recently submitted recipes which fit the returned weather data. The get_form_input function validates whether the user has really entered a location and sets the user's units and time in the local storage. Finally, the get_default and get_city functions return the location the user is currently in as a default value in the input box on the index page. An XML request is sent to the Location IQ API to get the location name based on the user's longitude and latitude.
The main function of recipes_script.js is that it determines which recipes to hide or display based on the user's filter settings, and to update the history API states to enable going backwards and forwards between the weather filter part of the recipes.html page and the results when the weather filter choices are submitted.
The .html files in templates/core consist of the basic HTML structure of each part of the website. In the index.html template there is a hidden element with the 'data-response' ID. This element only loads on the template if the Django back-end returned a context value called get-data set to 'yes'. This means that the weather data part of the index page has to be refreshed, so that if this element exists, a block of JavaScript in the script file runs another fetch request to update the new weather data from the server again, as the user may have had the weather results page up for a while and may want to refresh it with new information.
The CSS file in the static folder contains the styling for the whole application. The background image is set to clouds.jpg which is stored in this folder and if the user does not choose an image URL in the recipe they upload, the image for that recipe is automatically set to no_img.png.

## How to Run the Code

To run this program, you must have the most recent version of Python and pip3 installed. In the terminal, install the required Python modules using pip as detailed in the requirements file in the main app folder. Navigate into the weatherapp directory and run python manage.py runserver. There may be issues with the migration history if you are running Linux, for which these fix is very useful: https://stackoverflow.com/questions/64634674/django-typeerror-argument-of-type-posixpath-is-not-iterable.
After that, open a browser (this page is responsive in Chrome, Edge and Mozilla recent versions) and type in the local host URL with port 8000 in the URL bar. The page is now ready to explore.
