# Final Project for CS50W: Weather App

## Distinctiveness

The aim of my project was to create a web application where the user is able to type in their location and then receive suggestions about what to wear and what to cook based on the weather in their chosen location. I have made my application responsive on smaller screens using a mixture of Bootstrap 4 and custom CSS including grid layouts, flexbox, and media queries. The app is also interactive and dynamic because of my use of JavaScript, API fetch requests, and the History API using pushState and replaceState. 
This application is distinct from the other applications that I have created for this CS50 course as it is neither an e-commerce, a messaging, nor a social networking app. The function of this application is not to enable any buying and selling of goods or services between users, nor is it based on allowing messages and communication between people. There is a login option which enables the users to contribute to the database of recipes and food suggestions on the site but it is possible to use and enjoy the app without necessarily creating a user account. Anyone can type in the name of a city or town that they live in or want to visit and see the weather for either now, later in the day, or tomorrow, as well as lifestyle suggestions based on the returned and parsed data.

## Complexity

My project is significantly more complex in terms of both back-end and front end code than the other projects to date. Regarding the back-end, I have leveraged the power of models, model forms and JSONResponse as in the previous assignments. However, I have also created a list of complex functions in the functions.py document. These functions include the creation of a session to garner data from the Google search query for weather, to then parse the resulting HTML using Beautiful Soup, and creating an algorithm which takes the weather data, including variables such as wind and precipitation, to create a complex JSON object which returns the general weather assessment (or "feels-like" temperature) to the user, so that they can make a quick decision about what kind of produce to buy or what to wear. In terms of front-end, several sections of the app, especially the 'Recipes' section, work as a single-page app within the larger app. I have used logic in JavaScript to enable to user to select several filters at once to narrow down their results. As mentioned above, I have also used more complex CSS which was necessary to make the grid layout of the recipes completely responsive.

## File Contents

### Python/Back-End Files

#### views.py
In my main views.py file, I have created standard index, login, register and logout routes as demonstrated in the previous projects. Apart from that, I have implemented an API route called get_data which responds to the user entering his or her location on the index page, which then sends a fetch request in the JavaScript file. This back-end function verifies if this location really exists, which changes the tense (present/future) returned in the JSON response based on whether the user clicked to see the weather report for now or later, and which uses the functions contained in functions.py to 1) to get the weather data from Google and to process the data to return a JSON object with the information about the weather and recipe suggestions to be sent back to the user. There is also a login-only submit route which validates the form data sent by the user on submitting the 'Submit Recipe' form, which checks if the image extensions on the recipe image URL work and whether the recipe URL is valid. If so, the form information is stored as a Recipe object. The get_city route was something I implemented in order to allow the user to refresh the loaded weather report page, so that the information about the weather conditions would be loaded from Google again on refresh instead of displaying old information. This was done by sending a variable to the Django template which is then read by the JS code and sends a fetch request to the get_data route again to keep the data relevant.

#### models.py
The models.py file includes three models: the default User model, a Weather model which I have filled in with possible Google weather types as an admin, and a Recipe model which links to the weather model using a ManyToManyRelationship. I have include a default __str__ and a serialize method in each model. I have used multiple choices to enable the user submitting a recipe to select from different kinds of cuisine, diet, weather, and the time of meal.

#### forms.py
This file includes the Recipe form which serves as the template where a user can submit a new recipe when logged in. It also contains a stripped-down form called FilterForm with only the fields necessary for the user to filter down the recipes they want to see.

#### functions.py
This file defines two functions which validate the image URL that the user puts in while submitting the recipe, to make sure that the image's mimetype and format is in the above list of acceptable formats, as a security measure to make sure that the image that is linked is really an image file. The encode_weather_based_on_temp function rates the general weather condition based on the temperature and returns a general assessment of the temperature by adding more points the higher the temperature is. The change_feels_like_weather function changes the overall rating of the weather depending on the humidity and the wind speed. For exampele, if the weather is generally cold, then higher humidity makes it feel even colder, so the rating will be lower, whereas high humidity during warm weather will make it feel much warmer, so the rating is increased. get_html_content creates a fake user session to get Google weather data and returns it as a long chunk of HTML, which is then parsed in get_weather_data using Beautiful Soup 4 and passed into the functions mentioned above to calculate the general feels-like temperature. The find_recipes function is called within the get_weather_data function in order to get a list of recipes suitable for that particular weather type. The data is then encoded as a JSON object with sub-dictionaries for recipes and passed back to views.py